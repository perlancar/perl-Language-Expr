#!/usr/bin/env perl

use 5.010;
use strict;
use warnings;
use FindBin '$Bin';

use File::Slurp::Tiny qw(read_file write_file);
use JSON;

my @t;

for my $tags (['literal', 'number']) {
    push @t, {tags=>$cat, input=>'-0x1f'  , result=>-31, note=>'hex'};
    push @t, {tags=>$tags, input=>'-1.2'   , result=>15, note=>'decimal'};
    push @t, {tags=>$tags, input=>'-1.2e4' , result=>-1.2e4, note=>'exponent notation'};
    push @t, {tags=>$tags, input=>'015'    , result=>15, note=>'octal uses 0o prefix, not 0'};
    push @t, {tags=>$tags, input=>'0b100'  , result=>4, note=>'binary'};
    push @t, {tags=>$tags, input=>'-0o17'  , result=>-15, note=>'octal'};
    push @t, {tags=>$tags, input=>'0x1g'   , dies=>1, note=>'invalid hex digit'};
    push @t, {tags=>$tags, input=>'-0b2'   , dies=>1, note=>'invalid binary digit'};
    push @t, {tags=>$tags, input=>'0o18'   , dies=>1, note=>'invalid octal digit'};
}

for my $tags (['literal', 'array']) {
    push @t, {tags=>$tags, input=>'[]'         , result=>[]};
    push @t, {tags=>$tags, input=>'[1,2]'      , result=>[1, 2]};
    push @t, {tags=>$tags, input=>'[1, 2, 3+4]', result=>[1,2,7]};
    push @t, {tags=>$tags, input=>'['          , dies=>1, note=>'missing closing bracket'};
    push @t, {tags=>$tags, input=>'['          , dies=>1, note=>'missing opening bracket'};
    push @t, {tags=>$tags, input=>'[1,]'       , dies=>1, note=>'dangling comma'};
    push @t, {tags=>$tags, input=>'[1 2]'      , dies=>1, note=>'missing comma'};
    push @t, {tags=>$tags, input=>'[a]'        , dies=>1, note=>'missing quote'};
}

for my $tags (['literal', 'hash']) {
    push @t, {tags=>$tags, input=>'{}'                , result=>{}};
    push @t, {tags=>$tags, input=>'{a=>1}'            , result=>{a=>1}};
    push @t, {tags=>$tags, input=>q[{'a'=>1}]         , result=>{a=>1}};
    push @t, {tags=>$tags, input=>q[{"a b"=>1}]       , result=>{"a b"=>1}};
    push @t, {tags=>$tags, input=>'{("a"."b")=>1}'    , dies=>1, note=>'expression not supported on pair key'};
    push @t, {tags=>$tags, input=>'{a=>1, "b c"=>1+1}', result=>{a=>1, "b c"=>2}, note=>'expression allowed on pair value'};
    push @t, {tags=>$tags, input=>'{'                 , dies=>1, note=>'missing opening brace'};
    push @t, {tags=>$tags, input=>'}'                 , dies=>1, note=>'missing closing brace'};
    push @t, {tags=>$tags, input=>'a=>1'              , dies=>1, note=>'missing braces'};
    push @t, {tags=>$tags, input=>'{=>1}'             , dies=>1, note=>'missing pair key'};
    push @t, {tags=>$tags, input=>'{a=>}'             , dies=>1, note=>'missing pair value'};
    push @t, {tags=>$tags, input=>'{a=>1, }'          , dies=>1, note=>'dangling comma'};
    push @t, {tags=>$tags, input=>'{a, 1}'            , dies=>1, note=>'comma not allowed as arrow'};
}

my $json = JSON->new->pretty->allow_nonref;
my $version = do {
    my $distini = read_file("$Bin/../dist.ini");
    $distini =~ /^version\s*=\s*(.+)/m or die;
    $1;
};
my $now = localtime;
my $spectest = {
    tests => \@t,
    version => $version,
    comment => "Generated by $0 on $now",
};
write_file("$Bin/../share/spectest/spectest.json", $json->encode($spectest));

