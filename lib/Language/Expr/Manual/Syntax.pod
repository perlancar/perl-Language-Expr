# just to make PodWeaver happy at the moment
package Language::Expr::Manual::Syntax;
# ABSTRACT: Language::Expr::Manual::Syntax - Description of the Language::Expr language

=head1 OVERVIEW

Language::Expr language is very simple. It has just enough features to
support mathematical/logical/string operations, arrays, hashes,
variables, and function calls. It does not define any predefined
variables or builtin functions.

Language::Expr is (intentionally) not Turing-complete (lacks
assignment and loops).

It should be trivial to implement an interpreter or code generator
from the parser. In fact, Language::Expr is meant to be easily
convertible to Perl, PHP, and Javascript (among others like Python and
Ruby).


=head1 LITERALS

=head2 Undefined value

 undef

=head2 Boolean

 true
 false

=head2 Number

 1
 -2.3
 inf
 nan

=head2 String

Single-quoted strings, e.g. 'single quoted'. Supported escape
sequences:

 \'    literal single quote
 \\    literal backslash

Double-quoted strings, e.g. "double quoted". Supported escape
sequences:

 \'    literal single quote
 \"    literal double quote
 \\    literal backslash
 \$    prevent variable interpolation
 \t    tab
 \n    newline
 \r    linefeed
 \f    formfeed
 \b    backspace
 \a    bell
 \e    escape

 \0 or \03 or \033    octal char
 \x7 or \x7B          hex char
 \x{263a}             wide hex char

Difference with Perl: Perl supports a few other escape sequences, but
they are not commonly found in other scripting languages (e.g.: named
Unicode character or the \l, \L, et al), so they are not included.

Double-quoted strings will also interpolate variables, e.g.:

 "I have $num apples"
 "This is Foo::Bar version ${perl:/Foo/Bar/VERSION}"

=head2 Array

 []
 [1, 2, "str"]

Difference from Perl: dangling comma at the end is not allowed.

=head2 Hash

 {}
 {a => 1, "b c" => 2+3}

Difference from Perl: you must always use "=>" to separate key and
value, not comma. Dangling comma at the end is not allowed.


=head1 OPERATORS

Many operators are taken from Perl, along with their precedence levels
and associativity, but here are the differences:

=over 4

=item * No assigment operators.

Because assignment is not supported.

=item * No smart-match "~~" operator or the other more esoteric or Perl-specific operators.

These include Perl's "..", "...", "->", etc.

=item * Currently no "and", "or", "not" operators.

Use &&, ||, ! instead. Perl supports an extra, low-precedence set of
logical operators mostly to separate statements, which we do not have.

=item * "xor" becomes "^^" (to be consistent with "^" as bitwise-xor).

=item * Currently no tertiary "?:" operator.

Use B<if()> function instead (if it is supported by the interpreter).

=item * Hash value is accessed using [] instead of {}.

Which, BTW, is also the way it is done in Python, Ruby, and PHP.

=item * Comparison operators can be chained.

=back

Below is list of supported operators, ordered from lowest precedence,
along with their associativity.

 left     =>
 left     || // ^^
 left     &&
 left     | ^
 left     &
 nonassoc == != <=> cmp eq ne
 nonassoc < > <= >= ge gt le lt
 left     << >>
 left     + - .
 left     * / % x
 right    ! ~ unary+ unary-
 right    **
 left     hash[s], array[i]
 left     term (variable, str/num literals, (paren), func())


=head1 VARIABLES

There are two syntax of variables:

 $alphanum123
 $.
 $..

and:

 ${anything goes except closing curly brace}

Difference from Perl: The simple syntax does not allow
namespaces/package names (e.g. $foo::bar). In fact, the interpreter is
allowed to have its own namespace scheme. L<Data::Schema> and
L<Data::Template::Expr> uses a namespace + filesystem-like path
scheme, e.g.:

 ${../foo}
 ${/foo/bar/baz}
 ${schema:/foo/bar/baz}
 ${data:../../baz}

=head1 FUNCTIONS

Examples:

 rand()
 length("foo")

Difference from Perl: parentheses are required.

The language does not define list of known functions.


=cut
