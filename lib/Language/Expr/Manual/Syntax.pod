# just to make PodWeaver happy at the moment
package Language::Expr::Manual::Syntax;
# ABSTRACT: Description of the Language::Expr language

=head1 OVERVIEW

Language::Expr language is very simple. It has just enough features to
support mathematical/logical/string operations, arrays, hashes,
variables, and function calls.

Language::Expr is (intentionally) not Turing-complete (lacks
assignment and loops).

It should be trivial to implement an interpreter or code generator
from the parser. In fact, Language::Expr is meant to be easily
convertible to Perl, PHP, and Javascript (among others like Python and
Ruby).


=head1 LITERALS

=head2 Undefined value

 undef

=head2 Boolean

 true
 false

=head2 Number

 1
 -2.3
 inf
 nan

=head2 String

Single-quoted strings, e.g. 'single quoted'. Supported escape
sequences:

 \'    literal single quote
 \\    literal backslash

Double-quoted strings, e.g. "double quoted". Supported escape
sequences:

 \'    literal single quote
 \"    literal double quote
 \\    literal backslash
 \$    prevent variable interpolation
 \t    tab
 \n    newline
 \r    linefeed
 \f    formfeed
 \b    backspace
 \a    bell
 \e    escape

 \0 or \03 or \033    octal char
 \x7 or \x7B          hex char
 \x{263a}             wide hex char

Difference with Perl: Perl supports a few other escape sequences, but
they are not commonly found in other scripting languages (e.g.: named
Unicode character or the \l, \L, et al), so they are not included.

Double-quoted strings will also interpolate variables, e.g.:

 "I have $num apples"
 "This is Foo::Bar version ${perl:/Foo/Bar/VERSION}"

=head2 Array

 []
 [1, 2, "str"]

Difference from Perl: dangling comma at the end is not allowed.

=head2 Hash

 {}
 {a => 1, "b c" => 2+3}

Difference from Perl: you must always use "=>" to separate key and
value, not comma. Dangling comma at the end is not allowed.


=head1 OPERATORS

Many operators are taken from Perl, along with their precedence levels
and associativity, but here are the differences:

=over 4

=item * No assigment operators.

Because assignment is not supported.

=item * No smart-match "~~" operator or the other more esoteric or Perl-specific operators.

These include Perl's "..", "...", "->", etc.

=item * Currently no "and", "or", "not" operators.

Use &&, ||, ! instead. Perl supports an extra, low-precedence set of
logical operators mostly to separate statements, which we do not have.

=item * "xor" becomes "^^" (to be consistent with "^" as bitwise-xor).

=item * Currently no tertiary "?:" operator.

Use B<if()> function instead (availability depends on
interpreter/compiler).

=item * Hash value is accessed using [] instead of {}.

Which, BTW, is also the way it is done in Python, Ruby, and PHP.

=item * Comparison operators can be chained.

=back

Below is list of supported operators, ordered from lowest precedence,
along with their associativity.

 left     =>
 left     || // ^^
 left     &&
 left     | ^
 left     &
 left     == != <=> cmp eq ne
 left     < > <= >= ge gt le lt
 left     << >>
 left     + - .
 left     * / % x
 right    ! ~ unary+ unary-
 right    **
 left     hash[s], array[i]
 left     term (variable, str/num literals, (paren), func())


=head1 VARIABLES

There are two syntax of variables:

 $alphanum123 (including $_)
 $.
 $..

and:

 ${anything goes except closing curly brace}

Difference from Perl: The simple syntax does not allow
namespaces/package names (e.g. $foo::bar). In fact, the
compiler/interpreter is allowed to have its own namespace
scheme. L<Data::Schema> and L<Data::Template::Expr> uses a namespace +
filesystem-like path scheme, e.g.:

 ${../foo}
 ${/foo/bar/baz}
 ${schema:/foo/bar/baz}
 ${data:../../baz}

=head1 FUNCTIONS

Examples:

 rand()
 length("foo")

Difference from Perl: parentheses are required.

The language define just a few functions:

=head2 map({ EXPR }, ARRAY) -> RESULT_ARRAY

This is similar to Perl's map() (but notice the required parentheses),
it will form a new array composed from the result of EXPR. EXPR will
be evaluated for each element of ARRAY (stored in B<$_>). The original
value of $_ will be restored after EXPR completes.

=head2 grep({ EXPR }, ARRAY) -> RESULT_ARRAY

This is similar to Perl's grep() (but notice the required
parentheses), it will form a new array composed from the elements of
ARRAY when EXPR evaluates to true (like in Perl, empty string '', the
number 0, boolean C<false>, C<undef> are considered false). EXPR will
be evaluated for each element of ARRAY (stored in B<$_>). The original
value of $_ will be restored after EXPR completes.

=head2 usort({ EXPR }, ARRAY) -> RESULT_ARRAY

This is similar to Perl's sort() (but notice the required
parentheses), it will return the ARRAY sorted using comparison in
EXPR. EXPR will be evaluated for each element of ARRAY (B<$a> and
B<$b> will be set with two values to be compared). The original value
of B<$a> and B<$b> will be restored after EXPR completes.

=cut
