:default           ::= action=>::first
lexeme default       = latm=>1
:start             ::= answer

answer             ::= or_xor

    # precedence level : left     =>
pair               ::= word_G1 ('=>') value                    action=>rule_pair
                     | squotestr ('=>') value                  action=>rule_pair
                     | dquotestr ('=>') value                  action=>rule_pair
word_G1              ~ [\w]+
value              ::= answer

    # precedence level : left     || // ^^
or_xor             ::= ternary
                     | or_xor op_or_xor or_xor                 action=>rule_or_xor
op_or_xor          ::= '||' | '//' | '^^'

    # precedence level : right    ?:
ternary            ::= and
                    || ternary ('?') ternary (':') ternary     action=>rule_ternary assoc=>right

    # precedence level : left     &&
and                ::= bit_or_xor
                     | and '&&' and                            action=>rule_and

    # precedence level : left     | ^
bit_or_xor         ::= bit_and
                     | bit_or_xor op_bit_or_xor bit_or_xor     action=>rule_bit_or_xor
op_bit_or_xor        ~ '|' | '^'

    # precedence level : left     &
bit_and            ::= comparison3
                     | bit_and '&' bit_and                     action=>rule_bit_and

    # precedence level: group     <=> cmp
comparison3        ::= comparison
                     | comparison3 op_comparison3 comparison3  action=>rule_comparison3 assoc=>group
op_comparison3     ::= '<=>' | 'cmp'

    # precedence level: left == != eq ne < > <= >= ge gt le lt
comparison         ::= bit_shift
                     | comparison op_comparison comparison     action=>rule_comparison
op_comparison        ~ '==' | '!=' | 'eq' | 'ne' | '>=' | '>'
                     | '<=' | '<'  | 'lt' | 'gt' | 'le' | 'ge'

    # precedence level: left     << >>
bit_shift          ::= add
                     | bit_shift op_bit_shift bit_shift        action=>rule_bit_shift
op_bit_shift         ~ '<<' | '>>'

    # precedence level: left     + - .
add                ::= mult
                     | add op_add add                          action=>rule_add
op_add               ~ '+' | '-' | '.'

    # precedence level: left     * / % x
mult               ::= unary
                     | mult op_mult mult                       action=>rule_mult
op_mult              ~ '*' | '/' | '%' | 'x'

    # precedence level: right    ! ~ unary+ unary-
unary              ::= power
                     | op_unary unary                          action=>rule_unary
op_unary             ~ '!' | '~' | '+' | '-'

    # precedence level: right    **
power              ::= subscripting
                    || power '**' power                        action=>rule_power assoc=>right

    # precedence level: left    hash[s], array[i]
subscripting       ::= term
                     | var  ('[') term (']')                   action=>rule_subscripting_var
                     | term ('[') term (']')                   action=>rule_subscripting_expr

    # precedence level: left     term (variable, str/num literals, func(), (paren))
term               ::= func
                     | var
                     | str
                     | undef                                   action=>rule_undef
                     | num                                     action=>rule_num
                     | bool
                     | array
                     | hash
                     | '(' answer ')'                          action=>rule_parenthesis

    ####
array              ::= ('[') members (']')                     action=>rule_array
members            ::= answer*                                 separator=>comma action=>[values]
comma                ~ ','

hash               ::= ('{') pairs ('}')                       action=>rule_hash
pairs              ::= pair*                                   separator=>comma action=>[values]

undef                ~ 'undef'

bool                 ~ 'true' | 'false'

hexdigit             ~ [0-9A-Fa-f]
hexdigits            ~ hexdigit+
decdigits            ~ [0-9]+
octdigits            ~ [0-7]+
bindigits            ~ [01]+

sign                 ~ [+-]
num                  ~      '0x' hexdigits
                     | sign '0x' hexdigits
                     |      '0o' octdigits
                     | sign '0o' octdigits
                     |      '0b' bindigits
                     | sign '0b' bindigits
                     |      decdigits
                     | sign decdigits
                     |      decdigits '.' decdigits
                     | sign decdigits '.' decdigits
                     |      decdigits [Ee] decdigits
                     | sign decdigits [Ee] decdigits
                     |      decdigits [Ee] sign decdigits
                     | sign decdigits [Ee] sign decdigits
                     |      decdigits '.' decdigits [Ee] decdigits
                     | sign decdigits '.' decdigits [Ee] decdigits
                     |      decdigits '.' decdigits [Ee] sign decdigits
                     | sign decdigits '.' decdigits [Ee] sign decdigits
                     |      'inf'
                     | sign 'inf'
                     |      'nan'

str                ::= squotestr                               action=>rule_squotestr
                     | dquotestr                               action=>rule_dquotestr

squotepart           ~ '\\'
                     | '\' [']
                     | [^\\']
squoteparts          ~ squotepart*
squotestr            ~ ['] squoteparts [']

dquotepart           ~ '\\'
                     | '\' [']
                     | [^\\']
                     | '\0' | '\0' [0-7] | '\0' [0-7][0-7]
                     | '\x' hexdigit
                     | '\x' hexdigit hexdigit
                     | '\x{' hexdigit '}'
                     | '\x{' hexdigit hexdigit '}'
                     | '\x{' hexdigit hexdigit hexdigit '}'
                     | '\x{' hexdigit hexdigit hexdigit hexdigit '}'
                     | '\' ["$tnrfbae]
                     #| '\' [\d\D]
                     | var0
dquoteparts          ~ dquotepart*
dquotestr            ~ ["] dquoteparts ["]

word_L0              ~ [\w]+
subpkg               ~ '::' word_L0
subpkgs              ~ subpkg*
noncurlycloses       ~ [^}]+
var0                 ~ '$' word_L0
                     | '$' word_L0 subpkgs
                     | '${' noncurlycloses '}'
var                  ~ var0

word0                ~ [\w]*
func_name            ~ [A-Za-z_] word0
func_arg           ::= answer
func_args          ::= func_arg*                               separator=>comma action=>[values]
func               ::= func_name ('(') func_args (')')         action=>rule_func
                     | 'map'   ('(') ('{') answer ('}') (',') func_args (')')  action=>rule_func_map
                     | 'grep'  ('(') ('{') answer ('}') (',') func_args (')')  action=>rule_func_grep
                     | 'usort' ('(') ('{') answer ('}') (',') func_args (')')  action=>rule_func_usort

:discard             ~ ws
ws                   ~ [\s]+
